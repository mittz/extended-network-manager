package main

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"flag"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/signal"
	"time"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/filters"
	dockerclient "github.com/docker/docker/client"
	"github.com/gorilla/websocket"
	rancherclient "github.com/rancher/go-rancher/client"
)

const (
	providerStackServiceName = "nfv-system/provider"
	pipeworkStackServiceName = "nfv-system/pipework"
)

// Event is a structure used in subscribe
type Event struct {
	ID           string   `json:"id"`
	Name         string   `json:"name"`
	ResourceID   string   `json:"resourceId"`
	ResourceType string   `json:"resourceType"`
	Data         Data     `json:"data"`
	Provider     Provider `json:"provider"`
}

// Data is a structure used in Event
type Data struct {
	Resource Resource `json:"resource"`
}

// Resource is a structure used in Data
type Resource struct {
	ID         string                 `json:"id"`
	Name       string                 `json:"name"`
	State      string                 `json:"state"`
	HostID     string                 `json:"hostId"`
	ExternalID string                 `json:"externalId"`
	Labels     map[string]interface{} `json:"labels"`
}

// Provider is a struct having provider and target information
type Provider struct {
	Name     string   `json:"name"`
	Pipework Pipework `json:"pipework"`
}

// Pipework is a struct having pipework container information
type Pipework struct {
	DockerID string `json:"dockerId"`
}

// CompareMaps is a function to check if all of b is included in a
func CompareMaps(a map[string]interface{}, b map[string]interface{}) bool {
	for key := range b {
		if a[key] != b[key] {
			return false
		}
	}
	return true
}

// IsFilteredEvent is a function to filter the event by parameters
func IsFilteredEvent(event Event, resourceType string, state string, labels map[string]interface{}) bool {
	return (event.ResourceType == resourceType && event.Data.Resource.State == state && CompareMaps(event.Data.Resource.Labels, labels))
}

// GetContainersOfHost is a function to get containers list included in specified host
func GetContainersOfHost(hostID string) []Resource {
	opts := rancherclient.ClientOpts{}
	opts.Url = os.Getenv("CATTLE_URL")
	opts.AccessKey = os.Getenv("CATTLE_ACCESS_KEY")
	opts.SecretKey = os.Getenv("CATTLE_SECRET_KEY")
	rancherClient, _ := rancherclient.NewRancherClient(&opts)
	l := rancherclient.NewListOpts()
	c, _ := rancherClient.Container.List(l)

	resources := []Resource{}

	for _, v := range c.Data {
		if v.HostId == hostID {
			resources = append(resources, Resource{v.Id, v.Name, v.State, v.HostId, v.ExternalId, v.Labels})
		}
	}

	return resources
}

// SearchProviderName is a function to search container name of provider running host same as specified container
func SearchProviderName(hostID string) string {
	containers := GetContainersOfHost(hostID)
	var provider string

	for _, c := range containers {
		v, contain := c.Labels["io.rancher.stack_service.name"]
		if contain && v == providerStackServiceName {
			provider = c.Name
		}
	}

	return provider
}

// SearchPipeworkID is a function to search container id of pipework running host same as specified container
func SearchPipeworkID(hostID string) string {
	containers := GetContainersOfHost(hostID)
	var provider string

	for _, c := range containers {
		v, contain := c.Labels["io.rancher.stack_service.name"]
		if contain && v == pipeworkStackServiceName {
			provider = c.ID
		}
	}

	return provider
}

// CallPipework is a function to call provider trigger pipework
func CallPipework(event Event) {
	// exec.Command("docker", "exec", "-it", container.ID, "pipework", container.Networks.Public.HostInterface, "-i", container.Networks.Public.ContainerInterface, container.ID, container.Networks.Public.IPAddress, container.Networks.Public.MACAddress).Run()
	cl, err := dockerclient.NewEnvClient()
	if err != nil {
		log.Fatalf("%v", err)
	}

	// filtMap := map[string][]string{"name": {"<container_name>"}}
	filtMap := map[string][]string{}
	filtBytes, _ := json.Marshal(filtMap)
	filt, _ := filters.FromParam(string(filtBytes))

	opts := types.ContainerListOptions{
		All:     true,
		Quiet:   true,
		Filters: filt,
	}
	resp, err := cl.ContainerList(context.TODO(), opts)
	if err != nil {
		log.Fatalf("%v", err)
	}

	log.Println(resp)
}

// Run is a function to run controller event
func Run() {
	accessKey := os.Getenv("CATTLE_ACCESS_KEY")
	secretKey := os.Getenv("CATTLE_SECRET_KEY")

	u, err := url.Parse(os.Getenv("CATTLE_URL"))
	host := u.Host

	if err != nil {
		log.Fatal(err)
	}

	resourceType := "container"
	state := "running"
	labels := map[string]interface{}{}

	labels["info.kudamono.nfv.customer"] = "true"

	flag.Parse()
	log.SetFlags(0)

	interrupt := make(chan os.Signal, 1)
	signal.Notify(interrupt, os.Interrupt)

	h := http.Header{}
	h.Add("Authorization", "Basic "+base64.StdEncoding.EncodeToString([]byte(accessKey+":"+secretKey)))

	url := "ws://" + host + "/v1/subscribe?eventNames=resource.change"
	c, _, err := websocket.DefaultDialer.Dial(url, h)
	if err != nil {
		log.Fatal("", err)
	}
	defer c.Close()

	done := make(chan struct{})

	go func() {
		defer close(done)
		for {
			_, message, err := c.ReadMessage()
			if err != nil {
				log.Println("read:", err)
				return
			}
			var event Event

			if err := json.Unmarshal(message, &event); err != nil {
				log.Fatal("JSON Unmarshal error:", err)
				return
			}

			if IsFilteredEvent(event, resourceType, state, labels) {
				log.Println(string(message))
				CallPipework(event)
			}
		}
	}()

	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-done:
			return
		case t := <-ticker.C:
			err := c.WriteMessage(websocket.TextMessage, []byte(t.String()))
			if err != nil {
				log.Println("write:", err)
				return
			}
		case <-interrupt:
			log.Println("interrupt")

			err := c.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
			if err != nil {
				log.Println("write close:", err)
				return
			}
			select {
			case <-done:
			case <-time.After(time.Second):
			}
			return
		}
	}
}
